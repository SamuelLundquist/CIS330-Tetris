#include <time.h>
#include <thread>
#include <ncurses.h>
#include "definitions.h"

using namespace std;

Queue moveQueue;

int execute(int move);

unsigned int piece_size, numPieces, linePoints, alive, running;
int storeAvailable, nextPiece, dropSpeed;

int game()
{
	//if restart selected, game will restart after ending in main
	int restart = 0;

	//seed the random generator with the current internal timer
	srand(time(NULL));

	initPieces(min_piece_size, max_piece_size);
	initGameWindows();
	initBlockData();
	initPieceData();


	//Sets level and score, parameter is level
	initLevelAndScore(setLevel);

	alive = 1;
	running = 1;
	storeAvailable = 1;

	//threads to put moves into move queue
	thread dropThread(dropFunc);
	thread inputThread(inputFunc);

	makePiece(randPiece());

	//generate the next piece
	nextPiece = randPiece();
	dispPiece(hintWin, nextPiece);

	updateBlockWindow();

	while(alive)
	{
		//executes moves from the move queue generated by other threads
		if(moveQueue.HasMove())
		{
			int move = moveQueue.Dequeue();

			int handle = execute(move);

			//pauseGame returns -1 if quit is selected
			if(handle < 0)
			{
				restart = 1;
			}
			//event triggered if piece reaches the bottom
			else if(handle)
			{
				updateBlockWindow();
				checkLines();
				updateBlockWindow();
				//makePiece returns 1 if there is no space for
				//the new piece, meaning the game is over
				if (makePiece(nextPiece))
				{
					alive = 0;
					break;
				}
				nextPiece = randPiece();
				dispPiece(hintWin, nextPiece);
				storeAvailable = 1;
			}
			updateBlockWindow();
		}
	}

	freePieces();

	freePieceData();
	freeBlockData();

	dropThread.join();
	inputThread.join();


	werase(blockWin);   // remove block window
	wrefresh(blockWin);
	delwin(blockWin);


    mvwprintw(gameWin, 14, (gameWin_width/2)-6, "# Game Over # ");   // game over window
    //dis_score();      // display score
    store_score(); // mvwprintw(gameWin, 18, (gameWin_width/2)-6, "Your score is: xx");
    wrefresh(gameWin);
    getch();

	endwin();

	return restart;
}

//executes actions read from the moveQueue
int execute(int move)
{
	int bottomed = 0;
	switch(move){
		case(DROP_BLOCK):
			bottomed = dropPiece();
			break;
		case(AUTO_DROP):
			bottomed = dropPiece();
			break;
		case(MOVE_RIGHT):
			movePiece(1);
			break;
		case(MOVE_LEFT):
			movePiece(-1);
			break;
		case(ROTATE_BLOCK_CLOCKWISE):
			rotatePiece(1);
			break;
		case(ROTATE_BLOCK_COUNTERCLOCKWISE):
			rotatePiece(-1);
			break;
		case(STORE_PIECE):
			//only let the player store a piece once
			//each time the piece falls to the ground
			if(storeAvailable)
			{
				storePiece();
				dispPiece(storeWin,storedPiece);
				//in case the new piece was taken from nextPiece
				dispPiece(hintWin,nextPiece);
				storeAvailable = 0;
			}
			break;
		case(PAUSE_GAME):
			running = 0;
			int handle = pauseGame();
			if(handle < 0)
			{
				alive = 0;
				running = 1;
			}
			else if(handle == 0)
			{
				bottomed = -1;
				alive = 0;
				running = 1;
			}
			else
			{
				running = 1;
			}
			break;

	}
	return bottomed;
}

int restartGame()
{
	initscr(); //Init Ncurses
	noecho(); //function does not print input characters
	curs_set(0); //make blinking cursor invisible
	cbreak(); //ctrl + c will stop function
	initColors();
	int restart = game();
	return restart;
}
