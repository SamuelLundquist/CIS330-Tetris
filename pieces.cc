#include <stdlib.h>
#include <stdio.h>
#include <cstring>
#include "definitions.h"

using namespace std;


void initPieceData()
{
	piece.blocks = (int**)malloc(sizeof(int*) * max_piece_size);
	for(int i = 0; i < max_piece_size; i++)
	{
		piece.blocks[i] = (int*)malloc(sizeof(int) * 2);
	}
	piece.origin = (int*)malloc(sizeof(int) * 2);

}

void freePieceData()
{
	free(piece.origin);

	for(int i = 0; i < piece_size; i++)
	{
	free(piece.blocks[i]);
	}
	free(piece.blocks);
}

int** pieces;
void genPieces(int min, int max);
int* shapePiece(int n, int max, int* genarr);
void addPiece(int piecenum, int max, int* piecedata);

/*
Defines different types of blocks we might have
For starters, we have 7 shapes with 4 blocks apiece
note that display of y starts at 4

need to indicate:
piece color
piece origin upon initialization
x,y of each block upon initialization

Each piece {color, originx, originy, x1, y1, x2, y2, x3, y3, x4, y4}
*/

//if using random piece generation, the algorithm is set to
//cap at 7 pieces per size
//the number of pieces of sizes up to the classic tetromino are:
//size 1: 1, size 2: 1, size 3: 2, size 4: 7
void initPieces(int min, int max)
{

	//first calculate the number of pieces
	int i = min;
	numPieces = 0;
	while(i < 4 && i < max+1) 
	{	
		if(i == 1 || i == 2)
		{
			numPieces++;	
		}
		else if(i==3)
		{
			numPieces += 2;
		}
		i++;
	}
	//for the rest of the sizes, have 7 pieces
	numPieces += (max - i + 1)*7;
	pieces = (int**)malloc(sizeof(int*)*numPieces);
	for(int i = 0; i < numPieces; i++) 
	{
		pieces[i] = (int*)malloc(sizeof(int)*(3+2*max));
		for(int j = 0; j < 3+2*max; j++) 
		{
			pieces[i][j] = -1;
		}
	}
	genPieces(min, max);	
}


//generate all possible tetrominos of size min to size max
//formatted as said above initPieces
//if piece is smaller than max_piece_size, all excess entries are filled with -1
//pieces of size 5 or greater are generated by randomly adding a block to 
//each piece of size n-1
void genPieces(int min, int max)
{
	int csize = 1;
	int i = 0;
	int len = 3+2*max+1;

	//search until reach min, or until need to start generating pieces (size = 5)
	while(csize < min && csize < 5) 
	{
		csize++;
	}
	if(csize == 1)
	{
		//start at (4,4) : x=4 = center rounded left, y=4 = top of visible blocks
		//origin = (4,4). this is the first two entries after color
		int data[len] = {7,4,4,4,4,-1};
		addPiece(i, max, data);
		i++;
		csize++;
	}
	if(csize == 2 && csize <= max)
	{
		//c++ doesn't accept curly braced arrays as parameters to
		//functions, so must make a temporary container for the data
		int data[len] = {6,4,4,4,4,5,4,-1};
		addPiece(i, max, data);
		i++;
		csize++;
	}	
	if(csize == 3 && csize <= max)
	{
		//2 possible pieces this time: corner piece and length 3 line piece
		
		int dataa[len] = {5,4,4,3,4,4,4,5,4,-1};
		addPiece(i, max, dataa);
		i++;
		int datab[len] = {4,4,4,3,4,4,4,4,5,-1};
		addPiece(i, max, datab);
		i++;
		csize++;
	}
	//excess -1 character on pieces of max size is removed
	int tlen = len-1;
	//a generator array used to shape pieces of larger sizes
	int genarr[7][tlen];

	if(csize == 4 && csize <= max)
	{
		//regular tetris pieces
		int dataa[len] = {1, 4, 4, 3, 4, 4, 4, 5, 4, 6, 4, -1};
		addPiece(i, max, dataa); //line piece
		memcpy(genarr[0],pieces[i],sizeof(int)*(tlen));
		i++;
		int datab[len] = {2, 4, 4, 4, 5, 3, 4, 4, 4, 5, 4, -1};
		addPiece(i, max, datab); //T piece
		memcpy(genarr[1],pieces[i],sizeof(int)*(tlen));
		i++;
		int datac[len] = {3, 4, 4, 3, 5, 3, 4, 4, 4, 5, 4, -1};
		addPiece(i, max, datac); //L piece
		memcpy(genarr[2],pieces[i],sizeof(int)*(tlen));
		i++;
		int datad[len] = {4, 4, 4, 5, 5, 3, 4, 4, 4, 5, 4, -1};
		addPiece(i, max, datad); //Flipped L piece
		memcpy(genarr[3],pieces[i],sizeof(int)*(tlen));
		i++;
		int datae[len] = {5, 4, 5, 3, 5, 4, 5, 4, 4, 5, 4, -1};
		addPiece(i, max, datae); //S piece
		memcpy(genarr[4],pieces[i],sizeof(int)*(tlen));
		i++;
		int dataf[len] = {6, 4, 5, 4, 5, 5, 5, 3, 4, 4, 4, -1};
		addPiece(i, max, dataf); //Z piece
		memcpy(genarr[5],pieces[i],sizeof(int)*(tlen));
		i++;
		int datag[len] = {7, 5, 5, 4, 5, 5, 5, 4, 4, 5, 4, -1};
		addPiece(i, max, datag); //O piece
		memcpy(genarr[6],pieces[i],sizeof(int)*(tlen));
		i++;
		csize++;
	}
	while(csize <= max)
	{
		for(int j = 0; j < 7; j++)
		{
			int* tpiece = shapePiece(csize, max, genarr[j]);
			addPiece(i, max, tpiece);
			free(tpiece);
			i++;
			memcpy(pieces[i],genarr[j],sizeof(int)*(tlen));
		}
		csize++;
	}
	

	 
}

//from a piece of size n, create a new piece of size n+1 by adding a block
//to some random empty space next to a block in the original piece
//returns an array to be inputted into addPiece
int *shapePiece(int n, int max, int* genarr)
{
	int graph[n+1][n+1];
	for(int i = 0; i < n; i++)
	{
		for(int j = 0; j < n; j++)
		{
			graph[i][j] = 0;
		}
	}	
	int i = 1;
	int entry;
	while((entry = genarr[2*i+1]) != -1)
	{
	printf("GOT HERE");
	fflush(stdout);
		//graph[y-4][x] = color
		printf("%d ",genarr[2*i+2]);
		printf("\n%d",entry);
		fflush(stdout);
		graph[genarr[2*i+2]][entry] = genarr[0];
		i++;
	}
	printf("GOT HERE");
	fflush(stdout);
	int found = 0;
	int newx;
	int newy;
	while(!found) 
	{	
		//choose block in original piece
		int block = rand()%n;
		int blockx = genarr[3+2*block];
		int blocky = genarr[3+2*block]-4;
		//possible ways to move from block
		//(don't count up - don't want to go above the window)
		int options[3] = {0,1,-1};
		//randomize order of options
		for(int j = 0; j < 2; j++)
		{
			//psuedo-random number between j and 3
			int k = (rand()%3 + j)%3;
			//exchange entries k and j
			int t = options[k];
			options[k] = options[j];
			options[j] = t;
		}
		int dir;
		for(int j = 0; j < 3; j++)
		{
			if(dir = options[j])
			{
				if(!graph[blocky][blockx+dir])
				{
					found = 1;
					newx = blockx + dir;
					newy = blocky;
					break;
				
				}	
			}	
			else
			{
				if(!graph[blocky+1][blockx])
				{
					found = 1;
					newx = blockx;
					newy = blocky+1;
					break;
				}
			}
		}
	}
	int* newPiece= (int*)malloc(sizeof(int)*(3+2*max + 1));
	int j;
	for(j = 0; j < 3+2*n; j++)
	{
		newPiece[j] = genarr[j];
	}
	newPiece[j+1] = newx;
	newPiece[j+2] = newy;
	newPiece[j+3] = -1;
	return newPiece;
}

void addPiece(int piecenum, int max, int* piecedata)
{
	int i = 0;
	int entry;
	while((entry = piecedata[i]) != -1) 
	{
		pieces[piecenum][i] = entry;
		i++;
	}
	while(i < 3 + 2*max)
	{
		pieces[piecenum][i] = -1;
		i++;
	}
}

void freePieces()
{
	for(int i = 0; i < numPieces; i++) 
	{
		free(pieces[i]);
	}
	free(pieces);

}

//given piece number (int n), assign piece struct values and update
//block data matrix with piece
//return 1 if there is a piece there already (you lose)
int makePiece(int n)
{
	//determine piece size
	int i = 3;
	while((i-2 < max_piece_size) && pieces[n][2*i-1] != -1)
	{
		i++;
	}
	piece_size = i - 2;
	int game_over = 0;
	piece.origin[0] = pieces[n][1];
	piece.origin[1] = pieces[n][2];
	piece.color = pieces[n][0];
	for(int i = 0; i < piece_size; i++)
	{
		int y = pieces[n][2*i+4];
		int x = pieces[n][2*i+3];
		if(block_data[y][x]) 
		{
			game_over = 1;
		}
		block_data[y][x] = piece.color;
		piece.blocks[i][0] = x;
		piece.blocks[i][1] = y;
	}
	return game_over;
}

//randomly generate a piece from the possible list of pieces
int genPiece() 
{
	return(rand()%numPieces);
}

//
// Given array of x y coordinates, sets those coordinates
// to zero in block_data, which removes the piece
//
void clearPiece(int** blocks)
{
  for(int i = 0; i < piece_size; i++)
  {
    block_data[blocks[i][1]][blocks[i][0]] = 0;
  }
}

void movePiece(int n)
{
	if(!n) 
	{
		return;
	}
	
	int* newloc = (int*)malloc(sizeof(int)*2*piece_size);

	clearPiece(piece.blocks);

	int direction = n/abs(n);

	for(int i = piece_size; i--;) 
	{

		int nlx = piece.blocks[i][0] + direction;
		int nly = piece.blocks[i][1];
		newloc[2*i] = nlx;
		newloc[2*i+1] = nly;
		
		if(nlx < 0 || nlx >= blockWin_width || block_data[nly][nlx])
		{
			reconstructPiece(newloc);
			return;
		}
	}
	updateBlocks(newloc,piece.origin[0] + direction, piece.origin[1]);
}

int checkCandidate(int x, int shift, int* loc);

//rotate piece if space available
//positive input = clockwise, negative = counterclockwise
//
//create a "sub-graph" with respect to the origin of piece
//the x coordinate of each block = x - originx
//since y is inverted (starts at 0 from the top)
//y = originy - y
//clockwise rotation is: x = y, y = -x
//therefore, plug in above values of x to this equation
//then, check if space is open
//if so, update block data and piece data
void rotatePiece(int lr)
{
	if(!lr) //left/right must have value
	{
		return;
	}
	int originx = piece.origin[0];
	int originy = piece.origin[1];

	//possible candidates for rotation
	int numCand = 6;
	int candidates[numCand][2] = {{1,0},{1,1},{1,-1},{0,1},{1,2},{1,-2}};

	if(piece.color == 7 && piece_size == 4) //don't rotate squares
	{
		return;
	}

	int* newloc = (int*)malloc(sizeof(int)*2*piece_size);

	clearPiece(piece.blocks);

	for(int i = piece_size; i--;)
	{
		int oldx = piece.blocks[i][0] - originx;
		int oldy = originy - piece.blocks[i][1];

		int newx = (lr/abs(lr))*oldy;
		int newy = (lr/abs(lr))*-oldx;

		newloc[2*i] = piece.blocks[i][0] + (newx - oldx);
		newloc[2*i+1] = piece.blocks[i][1] - (newy - oldy);

							
	}
	for(int i = 0; i < numCand; i++) 
	{
		if(checkCandidate(candidates[i][0],candidates[i][1],newloc))
		{
			free(newloc);
			return;
		}
	}
	reconstructPiece(newloc);
	return;

}


//checks a candidate for rotation
//in order to avoid being unable to rotate because the piece is next to a wall
//rotate and then shift n units to the left/right
//
//if x parameter is 1, check the candidate corresponding to a x shift 
//if x is 0, perform a y shift (not inverted despite ncurses being inverted with
//respect to y coordinates - if shift = 1, piece will go UP 1)
//
//return 1 if the candidate is valid
int checkCandidate(int x, int shift, int* loc)
{
	int* newloc = (int*)malloc(sizeof(int)*2*piece_size);
	for(int i = piece_size; i--;)
	{
		int nlx = newloc[2*i] = loc[2*i] + shift*x;
		int nly = newloc[2*i+1] = loc[2*i+1] + shift*(x-1);
		//if there's a block there, or if the block is
		//outside of the window, this candidate is not valid
		if(nlx < 0 || nly < 0 || nlx >= blockWin_width || nly >= blockWin_height+4 
				|| block_data[nly][nlx])
		{
			free(newloc);
			return 0;
		}
	}
	//if all the blocks are valid, return the candidate
	updateBlocks(newloc, piece.origin[0]+shift*x, piece.origin[1]+shift*(x-1));
	return 1;

}

//drops a piece, returns 1 if piece has hit the ground (bottomed)
int dropPiece()
{

	int* newloc = (int*)malloc(sizeof(int)*2*piece_size);
	clearPiece(piece.blocks);
	for(int i = piece_size; i--;)
	{
		int nly = piece.blocks[i][1]+1;
		int x = piece.blocks[i][0];
		newloc[2*i] = x;
		newloc[2*i+1] = nly;

		if(nly>=24 || block_data[nly][x])
		{
			reconstructPiece(newloc);
			return 1;
		}

	}
	updateBlocks(newloc,piece.origin[0],piece.origin[1]+1);
	return 0;
}

void updateBlocks(int* newloc, int originx, int originy)
{
	//update the block data and piece data
	for(int i = piece_size; i--;)
	{
		block_data[newloc[2*i+1]][newloc[2*i]] = piece.color;

		//update blocks in piece, origin should stay the same
		piece.blocks[i][0] = newloc[2*i];
		piece.blocks[i][1] = newloc[2*i+1];

	}
	piece.origin[0] = originx;
	piece.origin[1] = originy;
	free(newloc);
}

//if the block can't move, reconstruct it where it was
void reconstructPiece(int* newloc)
{

	for(int i = piece_size; i--;)
	{
		block_data[piece.blocks[i][1]][piece.blocks[i][0]] = piece.color;
	}
	
	free(newloc);

}

int storedPiece = -1;

void storePiece() 
{

	//if there isn't already a stored piece, 
	if(storedPiece == -1) 
	{
		storedPiece = piece.color;
		clearPiece(piece.blocks);
		makePiece(nextPiece);
		nextPiece = genPiece();
		return;
	}
	int newPiece = storedPiece;
	storedPiece = piece.color;
	clearPiece(piece.blocks);
	//since piece array starts at 1, newPiece - 1
	makePiece(newPiece-1);
	return;
}
