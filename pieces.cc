#include <stdlib.h>
#include <stdio.h>
#include "definitions.h"

using namespace std;


void initPieceData()
{
	piece.blocks = (int**)malloc(sizeof(int*) * max_piece_size);
	for(int i = 0; i < max_piece_size; i++)
	{
		piece.blocks[i] = (int*)malloc(sizeof(int) * 2);
	}
	piece.origin = (int*)malloc(sizeof(int) * 2);

}

void freePieceData()
{
	free(piece.origin);

	for(int i = 0; i < piece_size; i++)
	{
	free(piece.blocks[i]);
	}
	free(piece.blocks);
}

int **pieces;
void genPieces(int min, int max);
void addPiece(int piecenum, int max, int* piecedata);

/*
Defines different types of blocks we might have
For starters, we have 7 shapes with 4 blocks apiece
note that display of y starts at 4

need to indicate:
piece color
piece origin upon initialization
x,y of each block upon initialization

Each piece {color, originx, originy, x1, y1, x2, y2, x3, y3, x4, y4}
*/

//if using random piece generation, the algorithm is set to
//cap at 7 pieces per size
//the number of pieces of sizes up to the classic tetromino are:
//size 1: 1, size 2: 1, size 3: 2, size 4: 7
void initPieces(int min, int max)
{

	//first calculate the number of pieces
	int i = min;
	numPieces = 0;
	while(i < 4 && i < max+1) 
	{	
		if(i == 1 || i == 2)
		{
			numPieces++;	
		}
		else if(i==3)
		{
			numPieces += 2;
		}
		i++;
	}
	printf("GOT HERE");
	fflush(stdout);
	//for the rest of the sizes, have 7 pieces
	numPieces += (max - i + 1)*7;
	pieces = (int**)malloc(sizeof(int*)*numPieces);
	for(int i = 0; i < numPieces; i++) 
	{
		pieces[i] = (int*)malloc(sizeof(int)*(3+2*max));
		for(int j = 0; j < 3+2*max; j++) 
		{
			pieces[i][j] = -1;
		}
	}
	genPieces(min, max);	
}


//generate all possible tetrominos of size min to size max
//formatted as said above initPieces
//if piece is smaller than max_piece_size, all excess entries are filled with -1
//pieces of size 5 or greater are generated by randomly adding a block to 
//each piece of size n-1
void genPieces(int min, int max)
{
	int csize = 1;
	int i = 0;

	//search until reach min, or until need to start generating pieces (size = 5)
	while(csize < min && csize < 5) 
	{
		csize++;
	}
	if(csize == 1)
	{
		//start at (4,4) : x=4 = center rounded left, y=4 = top of visible blocks
		//origin = (4,4). this is the first two entries after color
		int data[3+2*max+1] = {7,4,4,4,4,-1};
		addPiece(i, max, data);
		i++;
		csize++;
	}
	if(csize == 2 && csize <= max)
	{
		int data[3+2*max+1] = {6,4,4,4,4,5,4,-1};
		addPiece(i, max, data);
		i++;
		csize++;
	}	
	if(csize == 3 && csize <= max)
	{
		//2 possible pieces this time: corner piece and length 3 line piece
		
		int dataa[3+2*max+1] = {5,4,4,3,4,4,4,5,4,-1};
		addPiece(i, max, dataa);
		i++;
		int datab[3+2*max+1] = {4,4,4,3,4,4,4,4,5,-1};
		addPiece(i, max, datab);
		i++;
		csize++;
	}
	if(csize == 4 && csize <= max)
	{
		//regular tetris pieces
		int dataa[3+2*max+1] = {1, 4, 4, 3, 4, 4, 4, 5, 4, 6, 4, -1};
		addPiece(i, max, dataa); //line piece
		i++;
		int datab[3+2*max+1] = {2, 4, 4, 4, 5, 3, 4, 4, 4, 5, 4, -1};
		addPiece(i, max, datab); //T piece
		i++;
		int datac[3+2*max+1] = {3, 4, 4, 3, 5, 3, 4, 4, 4, 5, 4, -1};
		addPiece(i, max, datac); //L piece
		i++;
		int datad[3+2*max+1] = {4, 4, 4, 5, 5, 3, 4, 4, 4, 5, 4, -1};
		addPiece(i, max, datad); //Flipped L piece
		i++;
		int datae[3+2*max+1] = {5, 4, 5, 3, 5, 4, 5, 4, 4, 5, 4, -1};
		addPiece(i, max, datae); //S piece
		i++;
		int dataf[3+2*max+1] = {6, 4, 5, 4, 5, 5, 5, 3, 4, 4, 4, -1};
		addPiece(i, max, dataf); //Z piece
		i++;
		int datag[3+2*max+1] = {7, 5, 5, 4, 5, 5, 5, 4, 4, 5, 4, -1};
		addPiece(i, max, datag); //O piece
		i++;
		csize++;
	}



	 
}

void addPiece(int piecenum, int max, int* piecedata)
{
	int i = 0;
	int entry;
	while((entry = piecedata[i]) != -1) 
	{
		pieces[piecenum][i] = entry;
		i++;
	}
	while(i < 3 + 2*max)
	{
		pieces[piecenum][i] = -1;
		i++;
	}
}

void freePieces()
{
	for(int i = 0; i < numPieces; i++) 
	{
		free(pieces[i]);
	}
	free(pieces);

}

//given piece number (int n), assign piece struct values and update
//block data matrix with piece
//return 1 if there is a piece there already (you lose)
int makePiece(int n)
{
	//determine piece size
	int i = 3;
	while((i-2 < max_piece_size) && pieces[n][2*i-1] != -1)
	{
		i++;
	}
	piece_size = i - 2;
	int game_over = 0;
	piece.origin[0] = pieces[n][1];
	piece.origin[1] = pieces[n][2];
	piece.color = pieces[n][0];
	for(int i = 0; i < piece_size; i++)
	{
		int y = pieces[n][2*i+4];
		int x = pieces[n][2*i+3];
		if(block_data[y][x]) 
		{
			game_over = 1;
		}
		block_data[y][x] = piece.color;
		piece.blocks[i][0] = x;
		piece.blocks[i][1] = y;
	}
	return game_over;
}

//randomly generate a piece from the possible list of pieces
int genPiece() 
{
	return(rand()%numPieces);
}

//
// Given array of x y coordinates, sets those coordinates
// to zero in block_data, which removes the piece
//
void clearPiece(int** blocks)
{
  for(int i = 0; i < piece_size; i++)
  {
    block_data[blocks[i][1]][blocks[i][0]] = 0;
  }
}

void movePiece(int n)
{
	if(!n) 
	{
		return;
	}
	
	int* newloc = (int*)malloc(sizeof(int)*2*piece_size);

	clearPiece(piece.blocks);

	int direction = n/abs(n);

	for(int i = piece_size; i--;) 
	{

		int nlx = piece.blocks[i][0] + direction;
		int nly = piece.blocks[i][1];
		newloc[2*i] = nlx;
		newloc[2*i+1] = nly;
		
		if(nlx < 0 || nlx >= blockWin_width || block_data[nly][nlx])
		{
			reconstructPiece(newloc);
			return;
		}
	}
	updateBlocks(newloc,piece.origin[0] + direction, piece.origin[1]);
}

int checkCandidate(int x, int shift, int* loc);

//rotate piece if space available
//positive input = clockwise, negative = counterclockwise
//
//create a "sub-graph" with respect to the origin of piece
//the x coordinate of each block = x - originx
//since y is inverted (starts at 0 from the top)
//y = originy - y
//clockwise rotation is: x = y, y = -x
//therefore, plug in above values of x to this equation
//then, check if space is open
//if so, update block data and piece data
void rotatePiece(int lr)
{
	if(!lr) //left/right must have value
	{
		return;
	}
	int originx = piece.origin[0];
	int originy = piece.origin[1];

	//possible candidates for rotation
	int numCand = 6;
	int candidates[numCand][2] = {{1,0},{1,1},{1,-1},{0,1},{1,2},{1,-2}};

	if(piece.color == 7 && piece_size == 4) //don't rotate squares
	{
		return;
	}

	int* newloc = (int*)malloc(sizeof(int)*2*piece_size);

	clearPiece(piece.blocks);

	for(int i = piece_size; i--;)
	{
		int oldx = piece.blocks[i][0] - originx;
		int oldy = originy - piece.blocks[i][1];

		int newx = (lr/abs(lr))*oldy;
		int newy = (lr/abs(lr))*-oldx;

		newloc[2*i] = piece.blocks[i][0] + (newx - oldx);
		newloc[2*i+1] = piece.blocks[i][1] - (newy - oldy);

							
	}
	for(int i = 0; i < numCand; i++) 
	{
		if(checkCandidate(candidates[i][0],candidates[i][1],newloc))
		{
			free(newloc);
			return;
		}
	}
	reconstructPiece(newloc);
	return;

}


//checks a candidate for rotation
//in order to avoid being unable to rotate because the piece is next to a wall
//rotate and then shift n units to the left/right
//
//if x parameter is 1, check the candidate corresponding to a x shift 
//if x is 0, perform a y shift (not inverted despite ncurses being inverted with
//respect to y coordinates - if shift = 1, piece will go UP 1)
//
//return 1 if the candidate is valid
int checkCandidate(int x, int shift, int* loc)
{
	int* newloc = (int*)malloc(sizeof(int)*2*piece_size);
	for(int i = piece_size; i--;)
	{
		int nlx = newloc[2*i] = loc[2*i] + shift*x;
		int nly = newloc[2*i+1] = loc[2*i+1] + shift*(x-1);
		//if there's a block there, or if the block is
		//outside of the window, this candidate is not valid
		if(nlx < 0 || nly < 0 || nlx >= blockWin_width || nly >= blockWin_height+4 
				|| block_data[nly][nlx])
		{
			free(newloc);
			return 0;
		}
	}
	//if all the blocks are valid, return the candidate
	updateBlocks(newloc, piece.origin[0]+shift*x, piece.origin[1]+shift*(x-1));
	return 1;

}

//drops a piece, returns 1 if piece has hit the ground (bottomed)
int dropPiece()
{

	int* newloc = (int*)malloc(sizeof(int)*2*piece_size);
	clearPiece(piece.blocks);
	for(int i = piece_size; i--;)
	{
		int nly = piece.blocks[i][1]+1;
		int x = piece.blocks[i][0];
		newloc[2*i] = x;
		newloc[2*i+1] = nly;

		if(nly>=24 || block_data[nly][x])
		{
			reconstructPiece(newloc);
			return 1;
		}

	}
	updateBlocks(newloc,piece.origin[0],piece.origin[1]+1);
	return 0;
}

void updateBlocks(int* newloc, int originx, int originy)
{
	//update the block data and piece data
	for(int i = piece_size; i--;)
	{
		block_data[newloc[2*i+1]][newloc[2*i]] = piece.color;

		//update blocks in piece, origin should stay the same
		piece.blocks[i][0] = newloc[2*i];
		piece.blocks[i][1] = newloc[2*i+1];

	}
	piece.origin[0] = originx;
	piece.origin[1] = originy;
	free(newloc);
}

//if the block can't move, reconstruct it where it was
void reconstructPiece(int* newloc)
{

	for(int i = piece_size; i--;)
	{
		block_data[piece.blocks[i][1]][piece.blocks[i][0]] = piece.color;
	}
	
	free(newloc);

}

int storedPiece = -1;

void storePiece() 
{

	//if there isn't already a stored piece, 
	if(storedPiece == -1) 
	{
		storedPiece = piece.color;
		clearPiece(piece.blocks);
		makePiece(nextPiece);
		nextPiece = genPiece();
		return;
	}
	int newPiece = storedPiece;
	storedPiece = piece.color;
	clearPiece(piece.blocks);
	//since piece array starts at 1, newPiece - 1
	makePiece(newPiece-1);
	return;
}
